import IDeployer, { Configuration } from '../deployer';
import AWSDeploymentContext from './AWSDeploymentContext';
import {
	ElasticBeanstalk,
	ResourceGroups,
	Credentials,
	AWSError,
	S3
} from 'aws-sdk';
import {
	CreateGroupOutput,
	CreateGroupInput
} from 'aws-sdk/clients/resourcegroups';
import {
	CreateEnvironmentMessage,
	EnvironmentDescription,
	ApplicationDescriptionMessage,
	CreateApplicationMessage,
	CreateApplicationVersionMessage,
	ApplicationVersionDescriptionMessage,
	EnvironmentDescriptionsMessage
} from 'aws-sdk/clients/elasticbeanstalk';
import { ManagedUpload } from 'aws-sdk/lib/s3/managed_upload';
import { CreateBucketOutput } from 'aws-sdk/clients/s3';

export default class AWSDeployer implements IDeployer {
	constructor(private context: AWSDeploymentContext) {}
	private s3CodeKey = 'CODE';
	private waitTime = 5000;

	async deployResources(config?: Configuration): Promise<void> {
		await this.createResourceGroup();
		await this.createApplication();
		await this.createEnvironment();
		await this.createS3Bucket();
	}

	private createResourceGroup(): Promise<void> {
		const { resourceGroupName, region } = this.context;
		const group = new ResourceGroups({
			credentials: this.getCredentials(),
			region
		});

		const query = {
			ResourceTypeFilters: [
				'AWS::ElasticBeanstalk::Application',
				'AWS::ElasticBeanstalk::Environment'
			],
			TagFilters: [{ Key: 'graphroots', Values: ['generated'] }]
		};

		const options: CreateGroupInput = {
			Name: resourceGroupName,
			Description: 'Resource group generated by graphroots',
			ResourceQuery: { Type: 'TAG_FILTERS_1_0', Query: JSON.stringify(query) }
		};

		return new Promise((res, rej) => {
			group.createGroup(options, (err: AWSError, _: CreateGroupOutput) => {
				if (err && !err.message.includes('group already exists')) {
					rej(err);
					return;
				}

				res();
			});
		});
	}

	private createApplication(): Promise<void> {
		const { region, applicationName } = this.context;
		const elasticBeanstalk = new ElasticBeanstalk({
			credentials: this.getCredentials(),
			region
		});

		const options: CreateApplicationMessage = {
			ApplicationName: applicationName,
			Description: 'Graphroots generated application',
			Tags: [{ Key: 'graphroots', Value: 'generated' }]
		};

		return new Promise((res, rej) => {
			elasticBeanstalk.createApplication(
				options,
				(err: AWSError, _: ApplicationDescriptionMessage) => {
					if (
						err &&
						!err.message.includes(
							`Application ${applicationName} already exists`
						)
					) {
						rej(err);
						return;
					}

					res();
				}
			);
		});
	}

	private createEnvironment(): Promise<void> {
		const { region, applicationName } = this.context;
		const elasticBeanstalk = new ElasticBeanstalk({
			credentials: this.getCredentials(),
			region
		});

		const options: CreateEnvironmentMessage = {
			ApplicationName: applicationName,
			EnvironmentName: applicationName,
			SolutionStackName: '64bit Amazon Linux 2018.03 v4.10.1 running Node.js',
			Description: 'Graphroots generated environment',
			Tags: [{ Key: 'graphroots', Value: 'generated' }]
		};

		return new Promise((res, rej) => {
			elasticBeanstalk.createEnvironment(
				options,
				(err: AWSError, _: EnvironmentDescription) => {
					if (
						err &&
						!err.message.includes(
							`Environment ${applicationName} already exists`
						)
					) {
						rej(err);
						return;
					}

					res();
				}
			);
		});
	}

	private createS3Bucket(): Promise<void> {
		const { region, applicationName } = this.context;
		var s3 = new S3({ credentials: this.getCredentials(), region });

		return new Promise((res, rej) => {
			s3.createBucket(
				{ Bucket: `${applicationName}-bucket` },
				(err: AWSError, _: CreateBucketOutput) => {
					if (
						err &&
						!err.message.includes(
							'Your previous request to create the named bucket succeeded and you already own it.'
						)
					) {
						rej(err);
						return;
					}

					res();
				}
			);
		});
	}

	private getCredentials() {
		const { accessKeyId, secretAccessKey } = this.context;
		return new Credentials(accessKeyId, secretAccessKey);
	}

	async deployApplication(zipped: Buffer): Promise<void> {
		const { applicationName, region, applicationVersion } = this.context;
		const bucketName = `${applicationName}-bucket`;
		await this.uploadZip(bucketName, zipped);

		const elasticBeanstalk = new ElasticBeanstalk({
			credentials: this.getCredentials(),
			region
		});

		await this.createApplicationVersion(elasticBeanstalk, bucketName);

		/**
		 * If the environment is brand new and isn't in a ready state the update will fail.
		 * Therefore polling must be done to make sure the environment is ready before updating it.
		 * Currently this solution isn't ideal, as if an exception is thrown during the update inside the
		 * setTimeout the exception will be swallowed.
		 */
		if (!(await this.isEnvironmentReady(elasticBeanstalk))) {
			const id = setInterval(async () => {
				if (await this.isEnvironmentReady(elasticBeanstalk)) {
					clearInterval(id);
					await this.updateBeanstalkEnvironment(elasticBeanstalk);
				}
			}, this.waitTime);

			return;
		}

		return this.updateBeanstalkEnvironment(elasticBeanstalk);
	}

	private uploadZip(bucketName: string, zipped: Buffer): Promise<void> {
		const { region } = this.context;
		var s3 = new S3({ credentials: this.getCredentials(), region });

		return new Promise((res, rej) => {
			s3.upload(
				{
					Key: this.s3CodeKey,
					Body: zipped,
					Bucket: bucketName
				},
				{},
				(err: Error, _: ManagedUpload.SendData) => {
					if (err) {
						rej(err);
						return;
					}

					res();
				}
			);
		});
	}

	private createApplicationVersion(
		client: ElasticBeanstalk,
		bucketName: string
	) {
		const { applicationName, applicationVersion } = this.context;

		const options: CreateApplicationVersionMessage = {
			ApplicationName: applicationName,
			SourceBundle: {
				S3Bucket: bucketName,
				S3Key: this.s3CodeKey
			},
			VersionLabel: applicationVersion
		};

		return new Promise((res, rej) => {
			client.createApplicationVersion(
				options,
				(err: AWSError, _: ApplicationVersionDescriptionMessage) => {
					if (err) {
						rej(err);
						return;
					}

					res();
				}
			);
		});
	}

	private isEnvironmentReady(client: ElasticBeanstalk): Promise<boolean> {
		const { applicationName } = this.context;

		return new Promise((res, rej) => {
			client.describeEnvironments(
				{
					ApplicationName: applicationName,
					EnvironmentNames: [applicationName],
					IncludeDeleted: false
				},
				(err: AWSError, data: EnvironmentDescriptionsMessage) => {
					if (err) {
						rej(err);
						return;
					}

					const env = data.Environments.find(
						c => c.EnvironmentName === applicationName
					);

					if (!env) {
						rej(`No environment with name ${applicationName} found`);
						return;
					}

					res(env.Status && env.Status === 'Ready');
				}
			);
		});
	}

	private updateBeanstalkEnvironment(client: ElasticBeanstalk): Promise<void> {
		const { applicationName, applicationVersion } = this.context;

		return new Promise((res, rej) => {
			client.updateEnvironment(
				{
					ApplicationName: applicationName,
					EnvironmentName: applicationName,
					VersionLabel: applicationVersion
				},
				(err: AWSError, _: EnvironmentDescription) => {
					if (err) {
						rej(err);
						return;
					}

					res();
				}
			);
		});
	}
}
