import IDeployer, { Configuration } from '../deployer';
import AWSDeploymentContext from './AWSDeploymentContext';
import {
	ElasticBeanstalk,
	ResourceGroups,
	Credentials,
	AWSError,
	S3
} from 'aws-sdk';
import {
	CreateGroupOutput,
	CreateGroupInput
} from 'aws-sdk/clients/resourcegroups';
import {
	CreateEnvironmentMessage,
	EnvironmentDescription,
	ApplicationDescriptionMessage,
	CreateApplicationMessage,
	CreateApplicationVersionMessage,
	ApplicationVersionDescriptionMessage
} from 'aws-sdk/clients/elasticbeanstalk';
import { ManagedUpload } from 'aws-sdk/lib/s3/managed_upload';
import { CreateBucketOutput } from 'aws-sdk/clients/s3';

export default class AWSDeployer implements IDeployer {
	constructor(private context: AWSDeploymentContext) {}
	private S3CODEKEY = 'CODE';

	async deployResources(config?: Configuration): Promise<void> {
		await this.createResourceGroup();
		await this.createApplication();
		await this.createEnvironment();
		await this.createS3Bucket();
	}

	private createResourceGroup(): Promise<void> {
		const { resourceGroupName, region } = this.context;
		const group = new ResourceGroups({
			credentials: this.getCredentials(),
			region
		});

		const query = {
			ResourceTypeFilters: [
				'AWS::ElasticBeanstalk::Application',
				'AWS::ElasticBeanstalk::Environment'
			],
			TagFilters: [{ Key: 'graphroots', Values: ['generated'] }]
		};

		const options: CreateGroupInput = {
			Name: resourceGroupName,
			Description: 'Resource group generated by graphroots',
			ResourceQuery: { Type: 'TAG_FILTERS_1_0', Query: JSON.stringify(query) }
		};

		return new Promise((res, rej) => {
			group.createGroup(options, (err: AWSError, _: CreateGroupOutput) => {
				if (err && !err.message.includes('group already exists')) {
					rej(err);
					return;
				}

				res();
			});
		});
	}

	private createApplication(): Promise<void> {
		const { region, applicationName } = this.context;
		const elasticBeanstalk = new ElasticBeanstalk({
			credentials: this.getCredentials(),
			region
		});

		const options: CreateApplicationMessage = {
			ApplicationName: applicationName,
			Description: 'Graphroots generated application',
			Tags: [{ Key: 'graphroots', Value: 'generated' }]
		};

		return new Promise((res, rej) => {
			elasticBeanstalk.createApplication(
				options,
				(err: AWSError, _: ApplicationDescriptionMessage) => {
					if (
						err &&
						!err.message.includes(
							`Application ${applicationName} already exists`
						)
					) {
						rej(err);
						return;
					}

					res();
				}
			);
		});
	}

	private createEnvironment(): Promise<void> {
		const { region, applicationName } = this.context;
		const elasticBeanstalk = new ElasticBeanstalk({
			credentials: this.getCredentials(),
			region
		});

		const options: CreateEnvironmentMessage = {
			ApplicationName: applicationName,
			EnvironmentName: applicationName,
			SolutionStackName: '64bit Amazon Linux 2018.03 v4.10.1 running Node.js',
			Description: 'Graphroots generated environment',
			Tags: [{ Key: 'graphroots', Value: 'generated' }]
		};

		return new Promise((res, rej) => {
			elasticBeanstalk.createEnvironment(
				options,
				(err: AWSError, _: EnvironmentDescription) => {
					if (
						err &&
						!err.message.includes(
							`Environment ${applicationName} already exists`
						)
					) {
						rej(err);
						return;
					}

					res();
				}
			);
		});
	}

	private createS3Bucket(): Promise<void> {
		const { region, applicationName } = this.context;
		var s3 = new S3({ credentials: this.getCredentials(), region });

		return new Promise((res, rej) => {
			s3.createBucket(
				{ Bucket: `${applicationName}-bucket` },
				(err: AWSError, _: CreateBucketOutput) => {
					if (
						err &&
						!err.message.includes(
							'Your previous request to create the named bucket succeeded and you already own it.'
						)
					) {
						rej(err);
						return;
					}

					res();
				}
			);
		});
	}

	private getCredentials() {
		const { accessKeyId, secretAccessKey } = this.context;
		return new Credentials(accessKeyId, secretAccessKey);
	}

	async deployApplication(zipped: Buffer): Promise<void> {
		const { applicationName, region, applicationVersion } = this.context;
		const bucketName = `${applicationName}-bucket`;
		await this.uploadZip(bucketName, zipped);

		const elasticBeanstalk = new ElasticBeanstalk({
			credentials: this.getCredentials(),
			region
		});

		const options: CreateApplicationVersionMessage = {
			ApplicationName: applicationName,
			SourceBundle: {
				S3Bucket: bucketName,
				S3Key: this.S3CODEKEY
			},
			VersionLabel: applicationVersion
		};

		return new Promise((res, rej) => {
			elasticBeanstalk.createApplicationVersion(
				options,
				(err: AWSError, _: ApplicationVersionDescriptionMessage) => {
					if (err) {
						rej(err);
						return;
					}

					res();
				}
			);
		});
	}

	private uploadZip(bucketName: string, zipped: Buffer): Promise<void> {
		const { region } = this.context;
		var s3 = new S3({ credentials: this.getCredentials(), region });

		return new Promise((res, rej) => {
			s3.upload(
				{
					Key: this.S3CODEKEY,
					Body: zipped,
					Bucket: bucketName
				},
				{},
				(err: Error, _: ManagedUpload.SendData) => {
					if (err) {
						rej(err);
						return;
					}

					res();
				}
			);
		});
	}
}
